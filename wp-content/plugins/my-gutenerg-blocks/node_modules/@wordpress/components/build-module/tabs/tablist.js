/**
 * External dependencies
 */
// eslint-disable-next-line no-restricted-imports
import * as Ariakit from '@ariakit/react';

/**
 * WordPress dependencies
 */
import warning from '@wordpress/warning';
import { forwardRef, useEffect, useLayoutEffect, useRef, useState } from '@wordpress/element';

/**
 * Internal dependencies
 */

import { useTabsContext } from './context';
import { TabListWrapper } from './styles';
import clsx from 'clsx';
import { jsx as _jsx } from "react/jsx-runtime";
function useTrackElementOffset(targetElement, onUpdate) {
  const [indicatorPosition, setIndicatorPosition] = useState({
    left: 0,
    top: 0,
    width: 0,
    height: 0
  });

  // TODO: replace with useEventCallback or similar when officially available.
  const updateCallbackRef = useRef(onUpdate);
  useLayoutEffect(() => {
    updateCallbackRef.current = onUpdate;
  });
  const observedElementRef = useRef();
  const resizeObserverRef = useRef();
  useEffect(() => {
    if (targetElement === observedElementRef.current) {
      return;
    }
    observedElementRef.current = targetElement !== null && targetElement !== void 0 ? targetElement : undefined;
    function updateIndicator(element) {
      setIndicatorPosition({
        left: element.offsetLeft,
        top: element.offsetTop,
        width: element.offsetWidth,
        height: element.offsetHeight
      });
      updateCallbackRef.current?.();
    }

    // Set up a ResizeObserver.
    if (!resizeObserverRef.current) {
      resizeObserverRef.current = new ResizeObserver(() => {
        if (observedElementRef.current) {
          updateIndicator(observedElementRef.current);
        }
      });
    }
    const {
      current: resizeObserver
    } = resizeObserverRef;

    // Observe new element.
    if (targetElement) {
      updateIndicator(targetElement);
      resizeObserver.observe(targetElement);
    }
    return () => {
      // Unobserve previous element.
      if (observedElementRef.current) {
        resizeObserver.unobserve(observedElementRef.current);
      }
    };
  }, [targetElement]);
  return indicatorPosition;
}
function useOnValueUpdate(value, onUpdate) {
  const previousValueRef = useRef(value);

  // TODO: replace with useEventCallback or similar when officially available.
  const updateCallbackRef = useRef(onUpdate);
  useLayoutEffect(() => {
    updateCallbackRef.current = onUpdate;
  });
  useEffect(() => {
    if (previousValueRef.current !== value) {
      updateCallbackRef.current({
        previousValue: previousValueRef.current
      });
      previousValueRef.current = value;
    }
  }, [value]);
}
export const TabList = forwardRef(function TabList({
  children,
  ...otherProps
}, ref) {
  const context = useTabsContext();
  const selectedId = context?.store.useState('selectedId');
  const indicatorPosition = useTrackElementOffset(context?.store.item(selectedId)?.element);
  const [animationEnabled, setAnimationEnabled] = useState(false);
  useOnValueUpdate(selectedId, ({
    previousValue
  }) => previousValue && setAnimationEnabled(true));
  if (!context) {
    globalThis.SCRIPT_DEBUG === true ? warning('`Tabs.TabList` must be wrapped in a `Tabs` component.') : void 0;
    return null;
  }
  const {
    store
  } = context;
  const {
    activeId,
    selectOnMove
  } = store.useState();
  const {
    setActiveId
  } = store;
  const onBlur = () => {
    if (!selectOnMove) {
      return;
    }

    // When automatic tab selection is on, make sure that the active tab is up
    // to date with the selected tab when leaving the tablist. This makes sure
    // that the selected tab will receive keyboard focus when tabbing back into
    // the tablist.
    if (selectedId !== activeId) {
      setActiveId(selectedId);
    }
  };
  return /*#__PURE__*/_jsx(Ariakit.TabList, {
    ref: ref,
    store: store,
    render: /*#__PURE__*/_jsx(TabListWrapper, {
      onTransitionEnd: event => {
        if (event.pseudoElement === '::after') {
          setAnimationEnabled(false);
        }
      }
    }),
    onBlur: onBlur,
    ...otherProps,
    style: {
      '--indicator-left': `${indicatorPosition.left}px`,
      '--indicator-top': `${indicatorPosition.top}px`,
      '--indicator-width': `${indicatorPosition.width}px`,
      '--indicator-height': `${indicatorPosition.height}px`,
      ...otherProps.style
    },
    className: clsx(animationEnabled ? 'is-animation-enabled' : '', otherProps.className),
    children: children
  });
});
//# sourceMappingURL=tablist.js.map