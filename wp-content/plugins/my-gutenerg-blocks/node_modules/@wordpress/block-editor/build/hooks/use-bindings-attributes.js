"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canBindAttribute = canBindAttribute;
exports.canBindBlock = canBindBlock;
exports.withBlockBindingSupport = void 0;
var _blocks = require("@wordpress/blocks");
var _compose = require("@wordpress/compose");
var _data = require("@wordpress/data");
var _element = require("@wordpress/element");
var _hooks = require("@wordpress/hooks");
var _lockUnlock = require("../lock-unlock");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/** @typedef {import('@wordpress/compose').WPHigherOrderComponent} WPHigherOrderComponent */
/** @typedef {import('@wordpress/blocks').WPBlockSettings} WPBlockSettings */

/**
 * Given a binding of block attributes, returns a higher order component that
 * overrides its `attributes` and `setAttributes` props to sync any changes needed.
 *
 * @return {WPHigherOrderComponent} Higher-order component.
 */const BLOCK_BINDINGS_ALLOWED_BLOCKS = {
  'core/paragraph': ['content'],
  'core/heading': ['content'],
  'core/image': ['id', 'url', 'title', 'alt'],
  'core/button': ['url', 'text', 'linkTarget', 'rel']
};
const DEFAULT_ATTRIBUTE = '__default';

/**
 * Returns the bindings with the `__default` binding for pattern overrides
 * replaced with the full-set of supported attributes. e.g.:
 *
 * bindings passed in: `{ __default: { source: 'core/pattern-overrides' } }`
 * bindings returned: `{ content: { source: 'core/pattern-overrides' } }`
 *
 * @param {string} blockName The block name (e.g. 'core/paragraph').
 * @param {Object} bindings  A block's bindings from the metadata attribute.
 *
 * @return {Object} The bindings with default replaced for pattern overrides.
 */
function replacePatternOverrideDefaultBindings(blockName, bindings) {
  // The `__default` binding currently only works for pattern overrides.
  if (bindings?.[DEFAULT_ATTRIBUTE]?.source === 'core/pattern-overrides') {
    const supportedAttributes = BLOCK_BINDINGS_ALLOWED_BLOCKS[blockName];
    const bindingsWithDefaults = {};
    for (const attributeName of supportedAttributes) {
      // If the block has mixed binding sources, retain any non pattern override bindings.
      const bindingSource = bindings[attributeName] ? bindings[attributeName] : {
        source: 'core/pattern-overrides'
      };
      bindingsWithDefaults[attributeName] = bindingSource;
    }
    return bindingsWithDefaults;
  }
  return bindings;
}

/**
 * Based on the given block name,
 * check if it is possible to bind the block.
 *
 * @param {string} blockName - The block name.
 * @return {boolean} Whether it is possible to bind the block to sources.
 */
function canBindBlock(blockName) {
  return blockName in BLOCK_BINDINGS_ALLOWED_BLOCKS;
}

/**
 * Based on the given block name and attribute name,
 * check if it is possible to bind the block attribute.
 *
 * @param {string} blockName     - The block name.
 * @param {string} attributeName - The attribute name.
 * @return {boolean} Whether it is possible to bind the block attribute.
 */
function canBindAttribute(blockName, attributeName) {
  return canBindBlock(blockName) && BLOCK_BINDINGS_ALLOWED_BLOCKS[blockName].includes(attributeName);
}
const withBlockBindingSupport = exports.withBlockBindingSupport = (0, _compose.createHigherOrderComponent)(BlockEdit => props => {
  const registry = (0, _data.useRegistry)();
  const sources = (0, _data.useSelect)(select => (0, _lockUnlock.unlock)(select(_blocks.store)).getAllBlockBindingsSources());
  const {
    name,
    clientId,
    context
  } = props;
  const bindings = (0, _element.useMemo)(() => replacePatternOverrideDefaultBindings(name, props.attributes.metadata?.bindings), [props.attributes.metadata?.bindings, name]);
  const boundAttributes = (0, _data.useSelect)(() => {
    if (!bindings) {
      return;
    }
    const attributes = {};
    for (const [attributeName, boundAttribute] of Object.entries(bindings)) {
      const source = sources[boundAttribute.source];
      if (!source?.getValue || !canBindAttribute(name, attributeName)) {
        continue;
      }
      const args = {
        registry,
        context,
        clientId,
        attributeName,
        args: boundAttribute.args
      };
      attributes[attributeName] = source.getValue(args);
      if (attributes[attributeName] === undefined) {
        if (attributeName === 'url') {
          attributes[attributeName] = null;
        } else {
          attributes[attributeName] = source.getPlaceholder?.(args);
        }
      }
    }
    return attributes;
  }, [bindings, name, clientId, context, registry, sources]);
  const {
    setAttributes
  } = props;
  const _setAttributes = (0, _element.useCallback)(nextAttributes => {
    registry.batch(() => {
      if (!bindings) {
        setAttributes(nextAttributes);
        return;
      }
      const keptAttributes = {
        ...nextAttributes
      };
      const updatesBySource = new Map();

      // Loop only over the updated attributes to avoid modifying the bound ones that haven't changed.
      for (const [attributeName, newValue] of Object.entries(keptAttributes)) {
        if (!bindings[attributeName] || !canBindAttribute(name, attributeName)) {
          continue;
        }
        const binding = bindings[attributeName];
        const source = sources[binding?.source];
        if (!source?.setValue && !source?.setValues) {
          continue;
        }
        updatesBySource.set(source, {
          ...updatesBySource.get(source),
          [attributeName]: newValue
        });
        delete keptAttributes[attributeName];
      }
      if (updatesBySource.size) {
        for (const [source, attributes] of updatesBySource) {
          if (source.setValues) {
            source.setValues({
              registry,
              context,
              clientId,
              attributes
            });
          } else {
            for (const [attributeName, value] of Object.entries(attributes)) {
              const binding = bindings[attributeName];
              source.setValue({
                registry,
                context,
                clientId,
                attributeName,
                args: binding.args,
                value
              });
            }
          }
        }
      }
      if (Object.keys(keptAttributes).length) {
        setAttributes(keptAttributes);
      }
    });
  }, [registry, bindings, name, clientId, context, setAttributes, sources]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(BlockEdit, {
      ...props,
      attributes: {
        ...props.attributes,
        ...boundAttributes
      },
      setAttributes: _setAttributes
    })
  });
}, 'withBlockBindingSupport');

/**
 * Filters a registered block's settings to enhance a block's `edit` component
 * to upgrade bound attributes.
 *
 * @param {WPBlockSettings} settings - Registered block settings.
 * @param {string}          name     - Block name.
 * @return {WPBlockSettings} Filtered block settings.
 */
function shimAttributeSource(settings, name) {
  if (!canBindBlock(name)) {
    return settings;
  }
  return {
    ...settings,
    edit: withBlockBindingSupport(settings.edit)
  };
}
(0, _hooks.addFilter)('blocks.registerBlockType', 'core/editor/custom-sources-backwards-compatibility/shim-attribute-source', shimAttributeSource);
//# sourceMappingURL=use-bindings-attributes.js.map