"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.coordsToBackgroundPosition = exports.backgroundPositionToCoords = void 0;
exports.default = BackgroundPanel;
exports.hasBackgroundImageValue = hasBackgroundImageValue;
exports.hasBackgroundSizeValue = hasBackgroundSizeValue;
exports.useHasBackgroundPanel = useHasBackgroundPanel;
var _clsx = _interopRequireDefault(require("clsx"));
var _components = require("@wordpress/components");
var _i18n = require("@wordpress/i18n");
var _notices = require("@wordpress/notices");
var _url = require("@wordpress/url");
var _element = require("@wordpress/element");
var _data = require("@wordpress/data");
var _dom = require("@wordpress/dom");
var _blob = require("@wordpress/blob");
var _utils = require("./utils");
var _object = require("../../utils/object");
var _mediaReplaceFlow = _interopRequireDefault(require("../media-replace-flow"));
var _store = require("../../store");
var _themeFileUriUtils = require("./theme-file-uri-utils");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const IMAGE_BACKGROUND_TYPE = 'image';
const DEFAULT_CONTROLS = {
  backgroundImage: true,
  backgroundSize: false
};

/**
 * Checks site settings to see if the background panel may be used.
 * `settings.background.backgroundSize` exists also,
 * but can only be used if settings?.background?.backgroundImage is `true`.
 *
 * @param {Object} settings Site settings
 * @return {boolean}        Whether site settings has activated background panel.
 */
function useHasBackgroundPanel(settings) {
  return _element.Platform.OS === 'web' && settings?.background?.backgroundImage;
}

/**
 * Checks if there is a current value in the background size block support
 * attributes. Background size values include background size as well
 * as background position.
 *
 * @param {Object} style Style attribute.
 * @return {boolean}     Whether the block has a background size value set.
 */
function hasBackgroundSizeValue(style) {
  return style?.background?.backgroundPosition !== undefined || style?.background?.backgroundSize !== undefined;
}

/**
 * Checks if there is a current value in the background image block support
 * attributes.
 *
 * @param {Object} style Style attribute.
 * @return {boolean}     Whether the block has a background image value set.
 */
function hasBackgroundImageValue(style) {
  return !!style?.background?.backgroundImage?.id ||
  // Supports url() string values in theme.json.
  'string' === typeof style?.background?.backgroundImage || !!style?.background?.backgroundImage?.url;
}

/**
 * Get the help text for the background size control.
 *
 * @param {string} value backgroundSize value.
 * @return {string}      Translated help text.
 */
function backgroundSizeHelpText(value) {
  if (value === 'cover' || value === undefined) {
    return (0, _i18n.__)('Image covers the space evenly.');
  }
  if (value === 'contain') {
    return (0, _i18n.__)('Image is contained without distortion.');
  }
  return (0, _i18n.__)('Image has a fixed width.');
}

/**
 * Converts decimal x and y coords from FocalPointPicker to percentage-based values
 * to use as backgroundPosition value.
 *
 * @param {{x?:number, y?:number}} value FocalPointPicker coords.
 * @return {string}      				 backgroundPosition value.
 */
const coordsToBackgroundPosition = value => {
  if (!value || isNaN(value.x) && isNaN(value.y)) {
    return undefined;
  }
  const x = isNaN(value.x) ? 0.5 : value.x;
  const y = isNaN(value.y) ? 0.5 : value.y;
  return `${x * 100}% ${y * 100}%`;
};

/**
 * Converts backgroundPosition value to x and y coords for FocalPointPicker.
 *
 * @param {string} value backgroundPosition value.
 * @return {{x?:number, y?:number}}       FocalPointPicker coords.
 */
exports.coordsToBackgroundPosition = coordsToBackgroundPosition;
const backgroundPositionToCoords = value => {
  if (!value) {
    return {
      x: undefined,
      y: undefined
    };
  }
  let [x, y] = value.split(' ').map(v => parseFloat(v) / 100);
  x = isNaN(x) ? undefined : x;
  y = isNaN(y) ? x : y;
  return {
    x,
    y
  };
};
exports.backgroundPositionToCoords = backgroundPositionToCoords;
function InspectorImagePreview({
  label,
  filename,
  url: imgUrl
}) {
  const imgLabel = label || (0, _url.getFilename)(imgUrl) || (0, _i18n.__)('Add background image');
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalItemGroup, {
    as: "span",
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.__experimentalHStack, {
      justify: imgUrl ? 'flex-start' : 'center',
      as: "span",
      children: [imgUrl && /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: (0, _clsx.default)('block-editor-global-styles-background-panel__inspector-image-indicator-wrapper', {
          'has-image': imgUrl
        }),
        "aria-hidden": true,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          className: "block-editor-global-styles-background-panel__inspector-image-indicator",
          style: {
            backgroundImage: `url(${imgUrl})`
          }
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.FlexItem, {
        as: "span",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalTruncate, {
          numberOfLines: 1,
          className: "block-editor-global-styles-background-panel__inspector-media-replace-title",
          children: imgLabel
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.VisuallyHidden, {
          as: "span",
          children: imgUrl ? (0, _i18n.sprintf)( /* translators: %s: file name */
          (0, _i18n.__)('Background image: %s'), filename || imgLabel) : (0, _i18n.__)('No background image selected')
        })]
      })]
    })
  });
}
function BackgroundImageToolsPanelItem({
  panelId,
  isShownByDefault,
  onChange,
  style,
  inheritedValue,
  themeFileURIs
}) {
  const mediaUpload = (0, _data.useSelect)(select => select(_store.store).getSettings().mediaUpload, []);
  const {
    id,
    title,
    url
  } = style?.background?.backgroundImage || {
    ...inheritedValue?.background?.backgroundImage
  };
  const replaceContainerRef = (0, _element.useRef)();
  const {
    createErrorNotice
  } = (0, _data.useDispatch)(_notices.store);
  const onUploadError = message => {
    createErrorNotice(message, {
      type: 'snackbar'
    });
  };
  const resetBackgroundImage = () => onChange((0, _object.setImmutably)(style, ['background', 'backgroundImage'], undefined));
  const onSelectMedia = media => {
    if (!media || !media.url) {
      resetBackgroundImage();
      return;
    }
    if ((0, _blob.isBlobURL)(media.url)) {
      return;
    }

    // For media selections originated from a file upload.
    if (media.media_type && media.media_type !== IMAGE_BACKGROUND_TYPE || !media.media_type && media.type && media.type !== IMAGE_BACKGROUND_TYPE) {
      onUploadError((0, _i18n.__)('Only images can be used as a background image.'));
      return;
    }
    const sizeValue = style?.background?.backgroundSize;
    const positionValue = style?.background?.backgroundPosition;
    onChange((0, _object.setImmutably)(style, ['background'], {
      ...style?.background,
      backgroundImage: {
        url: media.url,
        id: media.id,
        source: 'file',
        title: media.title || undefined
      },
      backgroundPosition: !positionValue && ('auto' === sizeValue || !sizeValue) ? '50% 0' : positionValue
    }));
  };
  const onFilesDrop = filesList => {
    mediaUpload({
      allowedTypes: [IMAGE_BACKGROUND_TYPE],
      filesList,
      onFileChange([image]) {
        if ((0, _blob.isBlobURL)(image?.url)) {
          return;
        }
        onSelectMedia(image);
      },
      onError: onUploadError
    });
  };
  const resetAllFilter = (0, _element.useCallback)(previousValue => {
    return {
      ...previousValue,
      style: {
        ...previousValue.style,
        background: undefined
      }
    };
  }, []);
  const hasValue = hasBackgroundImageValue(style);
  const closeAndFocus = () => {
    const [toggleButton] = _dom.focus.tabbable.find(replaceContainerRef.current);
    // Focus the toggle button and close the dropdown menu.
    // This ensures similar behaviour as to selecting an image, where the dropdown is
    // closed and focus is redirected to the dropdown toggle button.
    toggleButton?.focus();
    toggleButton?.click();
  };
  const onRemove = () => onChange((0, _object.setImmutably)(style, ['background', 'backgroundImage'], 'none'));
  const canRemove = !hasValue && hasBackgroundImageValue(inheritedValue);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalToolsPanelItem, {
    className: "single-column",
    hasValue: () => hasValue,
    label: (0, _i18n.__)('Background image'),
    onDeselect: resetBackgroundImage,
    isShownByDefault: isShownByDefault,
    resetAllFilter: resetAllFilter,
    panelId: panelId,
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "block-editor-global-styles-background-panel__inspector-media-replace-container",
      ref: replaceContainerRef,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)(_mediaReplaceFlow.default, {
        mediaId: id,
        mediaURL: url,
        allowedTypes: [IMAGE_BACKGROUND_TYPE],
        accept: "image/*",
        onSelect: onSelectMedia,
        name: /*#__PURE__*/(0, _jsxRuntime.jsx)(InspectorImagePreview, {
          label: title,
          filename: title,
          url: (0, _themeFileUriUtils.getResolvedThemeFilePath)(url, themeFileURIs)
        }),
        variant: "secondary",
        children: [canRemove && /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.MenuItem, {
          onClick: () => {
            closeAndFocus();
            onRemove();
          },
          children: (0, _i18n.__)('Remove')
        }), hasValue && /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.MenuItem, {
          onClick: () => {
            closeAndFocus();
            resetBackgroundImage();
          },
          children: (0, _i18n.__)('Reset ')
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.DropZone, {
        onFilesDrop: onFilesDrop,
        label: (0, _i18n.__)('Drop to upload')
      })]
    })
  });
}
function BackgroundSizeToolsPanelItem({
  panelId,
  isShownByDefault,
  onChange,
  style,
  inheritedValue,
  defaultValues,
  themeFileURIs
}) {
  const sizeValue = style?.background?.backgroundSize || inheritedValue?.background?.backgroundSize;
  const repeatValue = style?.background?.backgroundRepeat || inheritedValue?.background?.backgroundRepeat;
  const imageValue = style?.background?.backgroundImage?.url || inheritedValue?.background?.backgroundImage?.url;
  const positionValue = style?.background?.backgroundPosition || inheritedValue?.background?.backgroundPosition;

  /*
   * An `undefined` value is replaced with any supplied
   * default control value for the toggle group control.
   * An empty string is treated as `auto` - this allows a user
   * to select "Size" and then enter a custom value, with an
   * empty value being treated as `auto`.
   */
  const currentValueForToggle = sizeValue !== undefined && sizeValue !== 'cover' && sizeValue !== 'contain' || sizeValue === '' ? 'auto' : sizeValue || defaultValues?.backgroundSize;

  /*
   * If the current value is `cover` and the repeat value is `undefined`, then
   * the toggle should be unchecked as the default state. Otherwise, the toggle
   * should reflect the current repeat value.
   */
  const repeatCheckedValue = !(repeatValue === 'no-repeat' || currentValueForToggle === 'cover' && repeatValue === undefined);
  const hasValue = hasBackgroundSizeValue(style);
  const resetAllFilter = (0, _element.useCallback)(previousValue => {
    return {
      ...previousValue,
      style: {
        ...previousValue.style,
        background: {
          ...previousValue.style?.background,
          backgroundRepeat: undefined,
          backgroundSize: undefined
        }
      }
    };
  }, []);
  const updateBackgroundSize = next => {
    // When switching to 'contain' toggle the repeat off.
    let nextRepeat = repeatValue;
    let nextPosition = positionValue;
    if (next === 'contain') {
      nextRepeat = 'no-repeat';
      nextPosition = undefined;
    }
    if (next === 'cover') {
      nextRepeat = undefined;
      nextPosition = undefined;
    }
    if ((currentValueForToggle === 'cover' || currentValueForToggle === 'contain') && next === 'auto') {
      nextRepeat = undefined;
      /*
       * A background image uploaded and set in the editor (an image with a record id),
       * receives a default background position of '50% 0',
       * when the toggle switches to "Tile". This is to increase the chance that
       * the image's focus point is visible.
       */
      if (!!style?.background?.backgroundImage?.id) {
        nextPosition = '50% 0';
      }
    }

    /*
     * Next will be null when the input is cleared,
     * in which case the value should be 'auto'.
     */
    if (!next && currentValueForToggle === 'auto') {
      next = 'auto';
    }
    onChange((0, _object.setImmutably)(style, ['background'], {
      ...style?.background,
      backgroundPosition: nextPosition,
      backgroundRepeat: nextRepeat,
      backgroundSize: next
    }));
  };
  const updateBackgroundPosition = next => {
    onChange((0, _object.setImmutably)(style, ['background', 'backgroundPosition'], coordsToBackgroundPosition(next)));
  };
  const toggleIsRepeated = () => onChange((0, _object.setImmutably)(style, ['background', 'backgroundRepeat'], repeatCheckedValue === true ? 'no-repeat' : 'repeat'));
  const resetBackgroundSize = () => onChange((0, _object.setImmutably)(style, ['background'], {
    ...style?.background,
    backgroundPosition: undefined,
    backgroundRepeat: undefined,
    backgroundSize: undefined
  }));
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.__experimentalVStack, {
    as: _components.__experimentalToolsPanelItem,
    spacing: 2,
    className: "single-column",
    hasValue: () => hasValue,
    label: (0, _i18n.__)('Size'),
    onDeselect: resetBackgroundSize,
    isShownByDefault: isShownByDefault,
    resetAllFilter: resetAllFilter,
    panelId: panelId,
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_components.FocalPointPicker, {
      __next40pxDefaultSize: true,
      label: (0, _i18n.__)('Position'),
      url: (0, _themeFileUriUtils.getResolvedThemeFilePath)(imageValue, themeFileURIs),
      value: backgroundPositionToCoords(positionValue),
      onChange: updateBackgroundPosition
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.__experimentalToggleGroupControl, {
      size: "__unstable-large",
      label: (0, _i18n.__)('Size'),
      value: currentValueForToggle,
      onChange: updateBackgroundSize,
      isBlock: true,
      help: backgroundSizeHelpText(sizeValue || defaultValues?.backgroundSize),
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalToggleGroupControlOption, {
        value: "cover",
        label: (0, _i18n.__)('Cover')
      }, "cover"), /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalToggleGroupControlOption, {
        value: "contain",
        label: (0, _i18n.__)('Contain')
      }, "contain"), /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalToggleGroupControlOption, {
        value: "auto",
        label: (0, _i18n.__)('Tile')
      }, "tile")]
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.__experimentalHStack, {
      justify: "flex-start",
      spacing: 2,
      as: "span",
      children: [currentValueForToggle !== undefined && currentValueForToggle !== 'cover' && currentValueForToggle !== 'contain' ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalUnitControl, {
        "aria-label": (0, _i18n.__)('Background image width'),
        onChange: updateBackgroundSize,
        value: sizeValue,
        size: "__unstable-large",
        __unstableInputWidth: "100px",
        min: 0,
        placeholder: (0, _i18n.__)('Auto')
      }) : null, currentValueForToggle !== 'cover' && /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.ToggleControl, {
        label: (0, _i18n.__)('Repeat'),
        checked: repeatCheckedValue,
        onChange: toggleIsRepeated
      })]
    })]
  });
}
function BackgroundToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children,
  headerLabel
}) {
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalVStack, {
    as: _components.__experimentalToolsPanel,
    spacing: 4,
    label: headerLabel,
    resetAll: resetAll,
    panelId: panelId,
    dropdownMenuProps: _utils.TOOLSPANEL_DROPDOWNMENU_PROPS,
    children: children
  });
}
function BackgroundPanel({
  as: Wrapper = BackgroundToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = DEFAULT_CONTROLS,
  defaultValues = {},
  headerLabel = (0, _i18n.__)('Background image'),
  themeFileURIs
}) {
  const resetAllFilter = (0, _element.useCallback)(previousValue => {
    return {
      ...previousValue,
      background: {}
    };
  }, []);
  const shouldShowBackgroundSizeControls = settings?.background?.backgroundSize;
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId,
    headerLabel: headerLabel,
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(BackgroundImageToolsPanelItem, {
      onChange: onChange,
      panelId: panelId,
      isShownByDefault: defaultControls.backgroundImage,
      style: value,
      inheritedValue: inheritedValue,
      themeFileURIs: themeFileURIs
    }), shouldShowBackgroundSizeControls && /*#__PURE__*/(0, _jsxRuntime.jsx)(BackgroundSizeToolsPanelItem, {
      onChange: onChange,
      panelId: panelId,
      isShownByDefault: defaultControls.backgroundSize,
      style: value,
      inheritedValue: inheritedValue,
      defaultValues: defaultValues,
      themeFileURIs: themeFileURIs
    })]
  });
}
//# sourceMappingURL=background-panel.js.map